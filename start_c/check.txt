Starting parse
Entering state 0
Reading a token: Next token is token DEF ()
Shifting token DEF ()
Entering state 1
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 6
Reading a token: Next token is token LP ()
Shifting token LP ()
Entering state 20
Reducing stack by rule 4 (line 49):
   $1 = token DEF ()
   $2 = token ID ()
   $3 = token LP ()
        .text
countdown:
        .data
 countdown_RA: .word 0
        .text
 sw $ra,countdown_RA

-> $$ = nterm headstart ()
Stack now 0
Entering state 4
Reading a token: Next token is token RP ()
Shifting token RP ()
Entering state 17
Reading a token: Next token is token COLON ()
Shifting token COLON ()
Entering state 26
Reading a token: Next token is token PRINT ()
Shifting token PRINT ()
Entering state 8
Reading a token: Next token is token LP ()
Shifting token LP ()
Entering state 21
Reading a token: Next token is token INTEGER ()
Shifting token INTEGER ()
Entering state 33
Reducing stack by rule 37 (line 94):
   $1 = token INTEGER ()
li $t0, 2
-> $$ = nterm factor ()
Stack now 0 4 17 26 8 21
Entering state 40
Reducing stack by rule 35 (line 91):
   $1 = nterm factor ()
-> $$ = nterm term ()
Stack now 0 4 17 26 8 21
Entering state 39
Reading a token: Next token is token RP ()
Reducing stack by rule 32 (line 87):
   $1 = nterm term ()
-> $$ = nterm exp ()
Stack now 0 4 17 26 8 21
Entering state 38
Next token is token RP ()
Reducing stack by rule 22 (line 75):
   $1 = nterm exp ()
-> $$ = nterm expression ()
Stack now 0 4 17 26 8 21
Entering state 36
Reducing stack by rule 53 (line 117):
   $1 = nterm expression ()
-> $$ = nterm expression_list ()
Stack now 0 4 17 26 8 21
Entering state 42
Next token is token RP ()
Shifting token RP ()
Entering state 77
Reducing stack by rule 44 (line 102):
   $1 = token PRINT ()
   $2 = token LP ()
   $3 = nterm expression_list ()
   $4 = token RP ()

li $v0,1
move $a0,$t0
syscall
-> $$ = nterm print_stmt ()
Stack now 0 4 17 26
Entering state 56
Reducing stack by rule 12 (line 61):
   $1 = nterm print_stmt ()
-> $$ = nterm statement ()
Stack now 0 4 17 26
Entering state 52
Reducing stack by rule 10 (line 58):
   $1 = nterm statement ()
-> $$ = nterm statements ()
Stack now 0 4 17 26
Entering state 51
Reading a token: Next token is token ENDDEF ()
Shifting token ENDDEF ()
Entering state 86
Reducing stack by rule 6 (line 52):
   $1 = nterm headstart ()
   $2 = token RP ()
   $3 = token COLON ()
   $4 = nterm statements ()
   $5 = token ENDDEF ()
        lw $t0,countdown_RA
        jr $t0
-> $$ = nterm function ()
Stack now 0
Entering state 5
Reducing stack by rule 3 (line 47):
   $1 = nterm function ()
-> $$ = nterm function_list ()
Stack now 0
Entering state 3
Reading a token: Next token is token PRINT ()
Shifting token PRINT ()
Entering state 8
Reading a token: Next token is token LP ()
Shifting token LP ()
Entering state 21
Reading a token: Next token is token INTEGER ()
Shifting token INTEGER ()
Entering state 33
Reducing stack by rule 37 (line 94):
   $1 = token INTEGER ()
li $t0, 3
-> $$ = nterm factor ()
Stack now 0 3 8 21
Entering state 40
Reducing stack by rule 35 (line 91):
   $1 = nterm factor ()
-> $$ = nterm term ()
Stack now 0 3 8 21
Entering state 39
Reading a token: Next token is token MUL ()
Shifting token MUL ()
Entering state 75
Reading a token: Next token is token INTEGER ()
Shifting token INTEGER ()
Entering state 33
Reducing stack by rule 37 (line 94):
   $1 = token INTEGER ()
li $t1, 2
-> $$ = nterm factor ()
Stack now 0 3 8 21 39 75
Entering state 101
Reducing stack by rule 33 (line 89):
   $1 = nterm term ()
   $2 = token MUL ()
   $3 = nterm factor ()
mul $t0,$t0,$t1
-> $$ = nterm term ()
Stack now 0 3 8 21
Entering state 39
Reading a token: Next token is token ADD ()
Reducing stack by rule 32 (line 87):
   $1 = nterm term ()
-> $$ = nterm exp ()
Stack now 0 3 8 21
Entering state 38
Next token is token ADD ()
Shifting token ADD ()
Entering state 67
Reading a token: Next token is token INTEGER ()
Shifting token INTEGER ()
Entering state 33
Reducing stack by rule 37 (line 94):
   $1 = token INTEGER ()
li $t1, 3
-> $$ = nterm factor ()
Stack now 0 3 8 21 38 67
Entering state 40
Reducing stack by rule 35 (line 91):
   $1 = nterm factor ()
-> $$ = nterm term ()
Stack now 0 3 8 21 38 67
Entering state 93
Reading a token: Next token is token MINUS ()
Reducing stack by rule 30 (line 85):
   $1 = nterm exp ()
   $2 = token ADD ()
   $3 = nterm term ()
add $t0,$t0,$t1
-> $$ = nterm exp ()
Stack now 0 3 8 21
Entering state 38
Next token is token MINUS ()
Shifting token MINUS ()
Entering state 68
Reading a token: Next token is token INTEGER ()
Shifting token INTEGER ()
Entering state 33
Reducing stack by rule 37 (line 94):
   $1 = token INTEGER ()
li $t1, 4
-> $$ = nterm factor ()
Stack now 0 3 8 21 38 68
Entering state 40
Reducing stack by rule 35 (line 91):
   $1 = nterm factor ()
-> $$ = nterm term ()
Stack now 0 3 8 21 38 68
Entering state 94
Reading a token: Next token is token DIV ()
Shifting token DIV ()
Entering state 76
Reading a token: Next token is token INTEGER ()
Shifting token INTEGER ()
Entering state 33
Reducing stack by rule 37 (line 94):
   $1 = token INTEGER ()
li $t2, 2
-> $$ = nterm factor ()
Stack now 0 3 8 21 38 68 94 76
Entering state 102
Reducing stack by rule 34 (line 90):
   $1 = nterm term ()
   $2 = token DIV ()
   $3 = nterm factor ()
div $t1,$t1,$t2
-> $$ = nterm term ()
Stack now 0 3 8 21 38 68
Entering state 94
Reading a token: Next token is token RP ()
Reducing stack by rule 31 (line 86):
   $1 = nterm exp ()
   $2 = token MINUS ()
   $3 = nterm term ()
sub $t0,$t0,$t1
-> $$ = nterm exp ()
Stack now 0 3 8 21
Entering state 38
Next token is token RP ()
Reducing stack by rule 22 (line 75):
   $1 = nterm exp ()
-> $$ = nterm expression ()
Stack now 0 3 8 21
Entering state 36
Reducing stack by rule 53 (line 117):
   $1 = nterm expression ()
-> $$ = nterm expression_list ()
Stack now 0 3 8 21
Entering state 42
Next token is token RP ()
Shifting token RP ()
Entering state 77
Reducing stack by rule 44 (line 102):
   $1 = token PRINT ()
   $2 = token LP ()
   $3 = nterm expression_list ()
   $4 = token RP ()

li $v0,1
move $a0,$t0
syscall
-> $$ = nterm print_stmt ()
Stack now 0 3
Entering state 12
Reducing stack by rule 59 (line 126):
   $1 = nterm print_stmt ()
-> $$ = nterm end ()
Stack now 0 3
Entering state 16
Reducing stack by rule 57 (line 123):
   $1 = nterm end ()
-> $$ = nterm end_list ()
Stack now 0 3
Entering state 15
Reading a token: Now at end of input.
Reducing stack by rule 1 (line 44):
   $1 = nterm function_list ()
   $2 = nterm end_list ()

li $v0,10
syscall
-> $$ = nterm program ()
Stack now 0
Entering state 2
Now at end of input.
Shifting token $end ()
Entering state 7
Stack now 0 2 7
Cleanup: popping token $end ()
Cleanup: popping nterm program ()
Input Passed Checking